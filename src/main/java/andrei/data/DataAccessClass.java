package andrei.data;

import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.lang.reflect.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;


/**
 * This class defines methods that do the CRUD operations in the database.
 * The object properties are created and read through reflection. A type T is
 * given as a parameter. At the base level, the functions create word by word
 * an SQL script that will provide the required operation in the database.
 * @param <T> the type parameter for the class: Order, Product or Client
 */

public class DataAccessClass<T> {
    private final Class<T> type;

    /**
     * Magic code line that generates the type parameter through reflection.
     */
    @SuppressWarnings("unchecked")
    public DataAccessClass() {
        this.type = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
    }

    /**
     * The query to select is very simple because the table name is the same as the class name,
     * so it is just one line. In the generated result set, we iterate entry by entry.
     * For each field that is in class<T> we get the corresponding method for writing and execute
     * it using the value returned from the result set. The object is then added to the list of objects.
     * At the end of the function, the list is returned.
     * @return a list of the objects extracted from the database.
     */
    public List<T> findAll() {
        List<T> list = new ArrayList<>();
        Connection connection = ConnectionFactory.getConnection();
        PreparedStatement statement;
        ResultSet res;
        try {
            String query = "SELECT * FROM " + type.getSimpleName();
            statement = connection.prepareStatement(query);
            res = statement.executeQuery();
            while (res.next()) {
                T entry = type.getDeclaredConstructor().newInstance();
                Field[] fields = type.getDeclaredFields();
                for (Field field : fields) {
                    PropertyDescriptor propertyDescriptor =
                            new PropertyDescriptor(field.getName(), type);
                    Object val = res.getObject(field.getName());
                    Method m = propertyDescriptor.getWriteMethod();
                    //log.info("field name = {},entry = {}, method = {}, val = {}",field.getName(),entry.getClass(),m.getName(), val.getClass());
                    m.invoke(entry, val);
                }
                list.add(entry);
            }

        } catch (SQLException ex) {
            ex.printStackTrace();
            System.err.println("SQLException in DAO class of type " + type.getSimpleName()+" and function findAll") ;
        }
        catch (IllegalAccessException ex)
        {
            ex.printStackTrace();
            System.err.println("IllegalAccessException in DAO class of type " + type.getSimpleName()+" and function findAll");
        }
        catch (NoSuchMethodException ex)
        {
            ex.printStackTrace();
            System.err.println("NoSuchMethodException in DAO class of type " + type.getSimpleName()+" and function findAll");
        }
        catch (InstantiationException ex)
        {
            ex.printStackTrace();
            System.err.println("InstantiationException in DAO class of type " + type.getSimpleName()+" and function findAll");
        }
        catch (InvocationTargetException ex)
        {
            ex.printStackTrace();
            System.err.println("InvocationTargetException in DAO class of type " + type.getSimpleName()+" and function findAll");
        } catch (IntrospectionException ex) {
            ex.printStackTrace();
            System.err.println("IntrospectionException in DAO class of type " + type.getSimpleName()+" and function findAll");
        }

        return list;
    }

    /**
     * The insert method will insert an object of generic type into the database.
     * First we iterate through field names and append them in the first parentheses, then
     * we invoke the read method for the object for each field. '' quotes are used to keep postgres happy.
     * Integer types are also quoted, but it does not affect the statement. No return.
     * @param obj -> object to be inserted into the database. Does not have an id, will be dynamically generated by the database.
     *            If the sequence in the database is corrupted, an exception will be thrown because of bad id generation.
     */
    public void insert(T obj) {
        Connection connection = ConnectionFactory.getConnection();
        PreparedStatement statement;
        try {
            StringBuilder query = new StringBuilder();
            query.append("INSERT INTO " + type.getSimpleName().toLowerCase() +" (");
            Field[] fields = type.getDeclaredFields();
            int i=0;
            for (Field field : fields) {
                if(i==0) {i++;continue;}
                query.append(field.getName() + ",");
            }
            query.deleteCharAt(query.length()-1);
            query.append(")");
            query.append(" VALUES ");
            query.append("(");
            i=0;
            for (Field field : fields) {
                if(i==0) {i++;continue;}
                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(field.getName(), type);
                Method m = propertyDescriptor.getReadMethod();
                query.append("'");
                if(field.getType() == String.class) query.append((String) m.invoke(obj));
                else query.append(m.invoke(obj));
                query.append("', ");
            }
            query.deleteCharAt(query.length()-1);
            query.deleteCharAt(query.length()-1);
            query.append(")");
            statement = connection.prepareStatement(query.toString());
            statement.executeUpdate();
        } catch (SQLException ex) {
            ex.printStackTrace();
            System.err.println("SQLException in DAO class of type " + type.getSimpleName()+" and function insert");
        } catch (IntrospectionException ex) {
            ex.printStackTrace();
            System.err.println("IntrospectionException in DAO class of type " + type.getSimpleName()+" and function insert");
        } catch (InvocationTargetException ex) {
            ex.printStackTrace();
            System.err.println("InvocationTargetException in DAO class of type " + type.getSimpleName()+" and function insert");
        } catch (IllegalAccessException ex) {
            ex.printStackTrace();
            System.err.println("IllegalAccessException in DAO class of type " + type.getSimpleName()+" and function insert");
        }
    }

    /**
     * The update method will edit an object already present in the database. The fields are already updated by the controller layer,
     * so we don't care about any of that. We will set all the fields as given. Thus, we call the field read method, read the properties,
     * append them and then call the statement. Big difference is that this time we have an id which shall be used in the WHERE clause
     * to identify the object in the database.
     * @param obj -> object to be updated in the database. Does have an id, it shall be used to uniquely identify the object.
     */
    public void update(T obj) {
        Connection connection;
        PreparedStatement statement;
        connection = ConnectionFactory.getConnection();
        StringBuilder query = new StringBuilder();
        query.append("UPDATE " + type.getSimpleName() + " SET ");
        Field[] fields = type.getDeclaredFields();
        int i=0;
        try {
            for (Field field : fields) {
                if(i==0) {i++;continue;} //skip id
                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(field.getName(), type);
                Method m = propertyDescriptor.getReadMethod();
                query.append(field.getName() + " = '");
                if(field.getType() == String.class) query.append((String) m.invoke(obj));
                else query.append(m.invoke(obj));
                query.append("'");
                query.append(",");
            }
            query.deleteCharAt(query.length()-1);
            query.append(" ");
            //ADD ID
            query.append("WHERE ");
            query.append(fields[0].getName()+ " = ");
            PropertyDescriptor propertyDescriptor = new PropertyDescriptor(fields[0].getName(), type);
            Method m = propertyDescriptor.getReadMethod();
            query.append(m.invoke(obj));
            statement = connection.prepareStatement(query.toString());
            statement.executeUpdate();
        } catch (SQLException ex) {
            ex.printStackTrace();
            System.err.println("SQLException in DAO class of type " + type.getSimpleName() +" and function update!");
        } catch (IntrospectionException ex) {
            ex.printStackTrace();
            System.err.println("IntrospectionException in DAO class of type " + type.getSimpleName()+" and function update!");
        } catch (InvocationTargetException ex) {
            ex.printStackTrace();
            System.err.println("InvocationTargetException in DAO class of type " + type.getSimpleName()+" and function update!");
        } catch (IllegalAccessException ex) {
            ex.printStackTrace();
            System.err.println("IllegalAccessException in DAO class of type " + type.getSimpleName()+" and function update!");
        }
    }
    public void delete(T obj)
    {
        Connection connection;
        PreparedStatement statement;
        connection = ConnectionFactory.getConnection();
        StringBuilder query = new StringBuilder();
        query.append("DELETE FROM " + type.getSimpleName() + " WHERE ");
        Field[] fields = type.getDeclaredFields();
        try {
            Field field = fields[0];
            PropertyDescriptor propertyDescriptor = new PropertyDescriptor(field.getName(), type);
            Method m = propertyDescriptor.getReadMethod();
            query.append(field.getName() + " = '");
            query.append(m.invoke(obj));
            query.append("'");
            statement = connection.prepareStatement(query.toString());
            statement.executeUpdate();
        } catch (SQLException ex) {
            ex.printStackTrace();
            System.err.println("SQLException in DAO class of type " + type.getSimpleName() +" and function delete!");
        } catch (IntrospectionException ex) {
            ex.printStackTrace();
            System.err.println("IntrospectionException in DAO class of type " + type.getSimpleName()+" and function delete!");
        } catch (InvocationTargetException ex) {
            ex.printStackTrace();
            System.err.println("InvocationTargetException in DAO class of type " + type.getSimpleName()+" and function delete!");
        } catch (IllegalAccessException ex) {
            ex.printStackTrace();
            System.err.println("IllegalAccessException in DAO class of type " + type.getSimpleName()+" and function delete!");
        }
    }

    //HELPER FUNCTIONS FROM THE BIG PROJECT

    @SuppressWarnings({"unchecked","rawtypes"})
    private List<T> createObjects(ResultSet resultSet) {
        List<T> list = new ArrayList<T>();
        Constructor[] ctors = type.getDeclaredConstructors();
        Constructor ctor = null;
        for (int i = 0; i < ctors.length; i++) {
            ctor = ctors[i];
            if (ctor.getGenericParameterTypes().length == 0)
                break;
        }
        try {
            while (resultSet.next()) {
                assert ctor != null;
                ctor.setAccessible(true);
                T instance = (T)ctor.newInstance();
                for (Field field : type.getDeclaredFields()) {
                    String fieldName = field.getName();
                    Object value = resultSet.getObject(fieldName);
                    PropertyDescriptor propertyDescriptor = new PropertyDescriptor(fieldName, type);
                    Method method = propertyDescriptor.getWriteMethod();
                    method.invoke(instance, value);
                }
                list.add(instance);
            }
        } catch (InstantiationException | IllegalAccessException | SecurityException | IllegalArgumentException |
                 InvocationTargetException | SQLException | IntrospectionException e) {
            e.printStackTrace();
        }
        return list;
    }
    private String createSelectQuery(String field) {
        StringBuilder sb = new StringBuilder();
        sb.append("SELECT ");
        sb.append(" * ");
        sb.append(" FROM ");
        sb.append(type.getSimpleName());
        sb.append(" WHERE " + field + " =?");
        return sb.toString();
    }

    /**
     * The function given by the template. Modified to catch exception of invalid id instead of termination.
     * @param id -> id of object to be inserted
     * @return -> found object or NULL in the case of failure
     */
    public T findById(int id) {
        Connection connection = null;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        Field[] fields = type.getDeclaredFields();
        String query = createSelectQuery(fields[0].getName());
        try {
            connection = ConnectionFactory.getConnection();
            statement = connection.prepareStatement(query);
            statement.setInt(1, id);
            resultSet = statement.executeQuery();
            try {
                return createObjects(resultSet).get(0);
            }catch (IndexOutOfBoundsException e)
            {
                return null;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ConnectionFactory.close(resultSet);
            ConnectionFactory.close(statement);
            ConnectionFactory.close(connection);
        }
        return null;
    }

    /**
     * This function returns the object with max id. Used by the bill generator to create the name since I have no idea
     * what id will be generated by the database, but I can be pretty certain it will be the biggest one.
     * @return -> object with the maximum id from column
     */
    public T findMaxId() throws IntrospectionException, InvocationTargetException, IllegalAccessException {
        List<T> objectSet = findAll();
        int max = -1;
        T maxT = null;
        Field[] fields = type.getDeclaredFields();
        for(T obj: objectSet)
        {
            PropertyDescriptor propertyDescriptor = new PropertyDescriptor(fields[0].getName(), type);
            Method m = propertyDescriptor.getReadMethod();
            int candidate =(int)m.invoke(obj);
            if(candidate > max)
            {
                max = candidate;
                maxT = obj;
            }
        }
        return maxT;
    }

}
